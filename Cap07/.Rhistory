vetor1 <- c(1:20)
vetor1
length(vetor1)
mode(vetor1)
class(vetor1)
typeof(vetor1)
matriz1 <- matrix(1:20, nrow = 2)
matriz1
length(matriz1)
mode(matriz1)
class(matriz1)
typeof(matriz1)
array1 <- array(1:5, dim = c(3, 3, 3))
array1
length(array1)
mode(array1)
class(array1)
typeof(array1)
View(iris)
length(iris)
mode(iris)
class(iris)
typeof(iris)
lista1 <- list(a = matriz1, b = vetor1)
lista1
length(lista1)
mode(lista1)
class(lista1)
typeof(lista1)
func1 <- function(x) {
var1 <- x * x
return(var1)
}
func1(5)
class(func1)
objects()
rm(array1, func1)
objects()
array1 <- array(1:5, dim = c(3, 3, 3))
func1 <- function(x) {
var1 <- x * x
return(var1)
}
q()
str <- c("Expressões", "regulares", "em linguagem R",
"permitem a busca de padrões", "e exploração de textos",
"podemos buscar padrões em dígitos",
"como por exemplo",
"10992451280")
length(str)
str
grep("ex", str, value = F)
grep("ex", str, value = T)
grep("\\d", str, value = F)
grep("\\d", str, value = T)
grepl("\\d+", str)
grepl("\\D", str)
gsub("em", "***", str)
gsub("ex", "EX", str, ignore.case = T)
sub("em", "EM", str)
frase <- "Isso é uma string."
regexpr(pattern = "u", frase)
gregexpr(pattern = "u", frase)
str2 <- c("2678 é maior que 45 - @???!§$",
"Vamos escrever 14 scripts R")
str2
gsub("\\d", "", str2)
gsub("\\D", "", str2)
gsub("\\s", "", str2)
gsub("[iot]", "Q", str2)
gsub("[[:punct:]]", "", str2)
q()
# Configurando o diretório de trabalho
# Coloque entre aspas o diretório de trabalho que você está usando no seu computador
# Não use diretórios com espaço no nome
setwd("~/Cursos/DSA/FCD/BigDataRAzure/Cap07")
# Para saber qual diretório estou trabalhando
getwd()
# Lista de pacotes base carregados
search()
## Vetores
x <- c("A", "E","D", "B","C")
x[]
x
# Índices Positivos - Elementos em posições específicas
x[c(1, 3)]
x[c(1 , 1)]
x[order(x)]
# Índices NEGATIVOS - Ignora elementos em posições específicas
# Retorna tudo Menos posições específicas
x[-c(1, 3)]
x[-c(1, 4)]
# Vetor Lógico para gerar subsetting
x[c(TRUE, FALSE)]
x[c(TRUE, FALSE, TRUE, FALSE)]
x[c(TRUE, FALSE, FALSE, FALSE)]
# Vetor de caracteres
y <- setNames(x, letters[1:4])
y
# Vetor de caracteres
x
y
# Vetor de caracteres
x <- ("A", "B", "C", "D")
# Vetor de caracteres
x <- c("A", "B", "C", "D")
y <- setNames(x, letters[1:4])
# criar um vetor de caracteres y atribuindo nomes as colunas.
x
y
y[c("d", "c", "a")]
y[c("a", "a", "a")]
## Matrizes
mat <- matrix(1:9, nrow = 3)
colnames(mat) <- c("A", "B", "C")
mat
## Matrizes
mat <- matrix(1:9, nrow = 3, byrow = 3)
colnames(mat) <- c("A", "B", "C")
mat
## Matrizes
mat <- matrix(1:9, nrow = 3, byrow = T)
colnames(mat) <- c("A", "B", "C")
mat
## Matrizes
mat <- matrix(1:9, nrow = 3, byrow = F)
colnames(mat) <- c("A", "B", "C")
mat
mat[1:2,]
mat[1:2, 2:3]
mat[, 1:2]
mat[, 2:3] # slicing de TODAS as linhas com as colunas 2 e 3
## Matrizes
mat <- matrix(1:9, nrow = 3, byrow = F)
colnames(mat) <- c("A", "B", "C")
mat
mat[1:2, ] # slicing da primeira e segunda linha com TODAS as colunas
mat[1:2, 2:3]
mat[, 2:3] # slicing de TODAS as linhas com as colunas 2 e 3
# Função outer() permite que uma Matriz se comporte como vetores individuais
?outer
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals
vals[4, 15]
vals[c(4, 15)]
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",", byrow = T)
# Concatendo dois vetores usando a função "paste" colocou uma virgula entre eles.
vals
vals[c(4, 15)]
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
# Concatendo dois vetores usando a função "paste" colocou uma virgula entre eles.
vals
vals[c(4, 15)]
vals <- outer(1:5, 1:5, FUN = "paste", byrow = T, sep = ",")
# Concatendo dois vetores usando a função "paste" colocou uma virgula entre eles.
vals
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
# Concatendo dois vetores usando a função "paste" colocou uma virgula entre eles.
vals
vals[c(4, 15)]
## Dataframes
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df
df$x
df$z
df[df$x == 2, ]
df[df$x == 3, ]
df[c(1, 2), ]
df[c("x", "z")]
df[ , c("x", "z")]
str(df["x"])
str(df[, "x"])
# Removendo colunas de dataframes
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df
df$z <- NULL
df
# Operadores [], [[]] e $
a <- list(x = 1:3, y = 4:5)
a
a[1]
a[[1]]
a[[1]][[1]]
a[["x"]]
a[2]
a[[1]]
a[[2]]
a[[1]][[3]]
a[[2]][[1]]
a[[2]][[3]]
a[[2]][[2]]
a[["x"]]
a[1]
a[[1]]
b <- list(a = list(b = list(c = list(d = 1))))
b
c[[c("a", "b", "c", "d")]]
b[[c("a", "b", "c", "d")]]
b[["a"]][["b"]][["c"]][["d"]]
# x$y é equivalente a x[["y", exact = FALSE]]
var <- "cyl"
mtcars$var
mtcars[[var]]
x <- list(abc = 1)
x$a
x[["a"]]
x
x[["abc"]]
# Subsetting e atribuição
x <- 1:5
x
x[c(1, 2)] <- 2:3
x
x[-1] <- 4:1
x
# Isso é subsetting
head(mtcars)
mtcars[] <- lapply(mtcars, as.integer)
head(mtcars)
# Isso não é subsetting
mtcars <- lapply(mtcars, as.integer)
head(mtcars)
# Lookup tables
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
unname(lookup[x])
# Usando operadores lógicos
x1 <- 1:10 %% 2 == 0
x1
which(x1)
x2 <- which(x1)
x2
y1 <- 1:10 %% 5 == 0
y2 <- which(y1)
y2
intersect(x2, y2)
x1 & y1
union(x2, y2)
setdiff(x2, y2)
# Sair
q()
